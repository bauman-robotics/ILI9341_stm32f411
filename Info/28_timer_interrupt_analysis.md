# 28. Анализ проблемы с прерыванием от таймера TIM1

## Введение
Пользователь столкнулся с проблемой, при которой при запуске кода (или подключении отладчика Cortex-Debug) программа оказывается в прерывании от таймера TIM1. Логи отладчика показывают остановку в обработчике `TIM1_UP_TIM10_IRQHandler`, который вызывает `HAL_TIM_IRQHandler` и далее `HAL_TIM_PeriodElapsedCallback`.

## Анализ логов Cortex-Debug
Из предоставленных логов видно следующее:

### Ключевые моменты из логов:
- Отладчик подключается к GDB на порту 3333.
- Программа останавливается по адресу `0x22694710` (вероятно, в стеке прерывания).
- Стек вызовов:
  1. Уровень 0: `?? ()` по адресу `0x22694710`
  2. Уровень 1: `<signal handler called>`
  3. Уровень 2: `HAL_TIM_IRQHandler` в `stm32f4xx_hal_tim.c:3825`
  4. Уровень 3: `TIM1_UP_TIM10_IRQHandler` в `stm32f4xx_it.c:186`
  5. Уровень 4: `<signal handler called>`
  6. Уровень 5: `Reset_Handler` в `startup_stm32f411xe.s:61`

- После `exec-continue` программа продолжает работать, но `backtrace` показывает "Selected thread is running."
- Установлены брейкпоинты в `freertos.c:378` (TouchTask), `main.c:77` и `102`, `touch_calibration.c:270`.

### Вывод из логов:
Программа останавливается в прерывании TIM1 сразу после подключения отладчика. Это указывает на то, что TIM1 генерирует прерывания, и отладчик ловит их.

## Анализ кода
### Конфигурация таймеров в проекте:
- **HAL (библиотека STM32)** использует **TIM1** как источник времени (timebase) для функций вроде `HAL_Delay()`, `HAL_GetTick()`. Это реализовано в `Core/Src/stm32f4xx_hal_timebase_tim.c`:
  - Функция `HAL_InitTick()` настраивает TIM1 с периодом 1 мс (1000000U / 1000U - 1U = 999).
  - Запускает таймер с `HAL_TIM_Base_Start_IT(&htim1)`.
  - Устанавливает прерывание `TIM1_UP_TIM10_IRQn` с приоритетом 0 (высокий).

- **FreeRTOS** использует **SysTick** как источник тиков (ticks). В `Core/Inc/FreeRTOSConfig.h`:
  - `#define xPortSysTickHandler SysTick_Handler`
  - `configTICK_RATE_HZ = 1000` (1000 тиков в секунду).
  - Приоритет SysTick: `configKERNEL_INTERRUPT_PRIORITY = 240` (низкий).

### Порядок инициализации:
1. В `main()`: `HAL_Init()` → вызывает `HAL_InitTick(0)`, который настраивает и запускает TIM1.
2. `SystemClock_Config()` → `HAL_RCC_ClockConfig()` → может вызвать `HAL_InitTick()` повторно.
3. Инициализация периферии (GPIO, SPI).
4. `MX_FREERTOS_Init()` → создаёт задачи.
5. `osKernelStart()` → запускает FreeRTOS.

### Причина проблемы:
- TIM1 начинает генерировать прерывания каждые 1 мс сразу после `HAL_Init()`, ещё до запуска FreeRTOS.
- Прерывания TIM1 имеют высокий приоритет (0), поэтому они прерывают основное выполнение.
- При подключении отладчика процессор останавливается в прерывании, так как отладчик "ловит" прерывания.
- После `exec-continue` программа продолжает работать, но если прерывания частые, отладчик может снова останавливаться.
- Конфликт: HAL и FreeRTOS используют разные таймеры, что приводит к дублированию источников времени и потенциальным сбоям в синхронизации.

## Возможные последствия
- Задержки в `HAL_Delay()` могут быть неточными из-за конфликта таймеров.
- Прерывания TIM1 могут мешать работе FreeRTOS (например, если приоритет TIM1 выше, чем у задач FreeRTOS).
- Отладка затруднена, так как программа "застревает" в прерывании.

## Предлагаемые решения

### Решение 1: Изменить источник времени HAL на другой таймер (рекомендуется TIMx, а не SysTick при использовании RTOS)
**Важно:** При использовании RTOS (как FreeRTOS) рекомендуется использовать HAL timebase source, отличный от SysTick, чтобы избежать конфликтов. Выберите другой таймер (TIM2, TIM3 и т.д.) вместо TIM1.

1. В STM32CubeMX:
   - Откройте проект (.ioc файл).
   - Перейдите в раздел **System Core > SYS** (или Pinout tab > SYS).
   - В **Timebase Source** выберите другой таймер (например, TIM2, TIM3, TIM4 и т.д.) вместо **TIM1**. **Не выбирайте SysTick**, так как FreeRTOS его использует.
   - Перегенерируйте код (Project > Generate Code).

2. После регенерации:
   - HAL будет использовать выбранный таймер (например, TIM2) для `HAL_GetTick()` и `HAL_Delay()`.
   - TIM1 освободится для других целей (например, для PWM или захвата).
   - FreeRTOS продолжит использовать SysTick без конфликтов.

3. Преимущества:
   - Полностью устраняет конфликт между HAL и FreeRTOS.
   - TIM1 освобождается для пользовательских задач.
   - Упрощает отладку и предотвращает прерывания от TIM1.

4. Недостатки:
   - Требует перегенерации кода в CubeMX.
   - Если выбранный таймер уже используется, нужно перенести функции на другой таймер.

### Решение 2: Изменить приоритет прерывания TIM1
Если нельзя изменить источник времени:
1. В `Core/Src/stm32f4xx_hal_timebase_tim.c`, в функции `HAL_InitTick()`:
   - Измените приоритет с `TickPriority` на более низкий (например, 5 или выше).
   - Вместо `HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, TickPriority, 0U);` используйте фиксированный приоритет, например, `HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, 5, 0U);`.

2. Убедитесь, что приоритет TIM1 ниже, чем у SysTick и других прерываний FreeRTOS.

3. Преимущества:
   - Быстрое исправление без перегенерации.
   - Сохраняет использование TIM1 для HAL.

4. Недостатки:
   - Всё равно два таймера работают параллельно.
   - Риск неточностей в тайминге.

### Решение 3: Отключить TIM1 для HAL и использовать SysTick вручную
1. Закомментируйте `HAL_TIM_Base_Start_IT(&htim1);` в `HAL_InitTick()`.
2. Реализуйте собственный `HAL_GetTick()` на основе SysTick (если необходимо).

3. Преимущества:
   - Устраняет прерывания TIM1.

4. Недостатки:
   - `HAL_Delay()` может не работать корректно.
   - Требует дополнительного кода.

### Решение 4: Проверить и исправить двойную инициализацию
- В `HAL_InitTick()` добавьте проверку, чтобы функция не инициализировала TIM1 повторно.
- Например, добавьте статическую переменную для отслеживания инициализации.

### Дополнительные рекомендации
- После применения решения протестируйте:
  - Запустите отладку и убедитесь, что программа не останавливается в прерывании TIM1.
  - Проверьте точность `HAL_Delay(1000)` (должна быть ~1 секунда).
  - Убедитесь, что FreeRTOS работает корректно (задачи переключаются).
- Если проблема сохраняется, проверьте регистры TIM1 в отладчике (например, TIM1->SR для статуса прерываний).
- Для глубокого анализа используйте RTT (Real-Time Transfer) вместо USB CDC для логирования, чтобы избежать конфликтов.

## Заключение
Проблема вызвана конфликтом между TIM1 (для HAL) и SysTick (для FreeRTOS). Рекомендуется изменить источник времени HAL на другой таймер (TIM2, TIM3 и т.д.) в CubeMX для полного устранения конфликта. Не используйте SysTick при RTOS. Если это невозможно, снизьте приоритет TIM1. После исправления отладка должна стать стабильной.
