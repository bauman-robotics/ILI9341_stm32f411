
# Промпты: 

1. 
Познакомься с проектом, 
На базе подключения дисплея и микроконтроллера, описанного в cubeMX 
ILI9341/ST7789V(with Touch)
stm32f411ceu6 

1. Составь план работы по написанию hello-world на данном дисплее, 
используя freertos, запиши его в текстовый файл в формате md под именем 03...md. 

2. Создай текстовый файл 04...md и запиши туда, список необходимого программного 
инструментария для компиляции и отладки кода для этого микроконтроллера. 
Напиши список консольных команд, для линукс тестирования, определяющих наличия этих инструментов. 

3. Создай текстовый файл 05... и опиши способ получения шрифтов для этого дисплея. 
Есть ли шрифты с кириллицей.

4. Давай сделаем первый шаг. Напиши код мигания лампочкой на ноге pc13 через фриртос. 

5. Создай конфигурацию для vscode, реализуй на нижней панели кнопки компиляции, очистки и загрузки кода в микроконтроллер, используя st-utils 

6. Добавил файлы со шрифтами. Перенес текстовые файлы в папку инфо, теперь будет использовать эту папку для описания. Создай код, который включает подсветку экрана BACK_LIGHT_Pin, и выводит надпись Hello_world на экран
двумя имеющимися шрифтами. 

7. Зафиксируй ситуацию. Подсветка загарается, надписей на экране нет. 
    Добавил класс CDC в проект через cubeMX. Напиши реализацию отправки текстовых логов через этот интерфейс. 
    Из логов должно быть видно, инициализируется ли корректно spi дисплей, корректные ли значения возвращаются из регистров, записываются ли корректные значения. 

8. Была проблема - не был подключен пин DC. Подключил его к PA4. Появились две надписи на экране белым цветом и красным (маленькие буквы). Видна проблема со шрифтами. 
   Посмотри те шрифты, которые я добавил Font_13 и Font_19 мы можем их использовать?
   При подключении CDC порт поднимается /dev/ACM0 но данные ни какие не приходят на компьютер при после ресета stm32. Проверь, что у нас с логами.  

9. Результаты. 
    1.Появились логи, но проблема с переходом на новую строку, очень много пробелов и смещение. Вот лог:
System: Starting application
                            GPIO: Turning on backlight
                                                      ILI9341: Starting initialization...
                                                                                         ILI9341: Hardware reset
                                                                                                                ILI9341: Software reset
                                                                                                                                       ILI9341: Sleep out
                                                                                                                                                         ILI9341: Display on
                                                                                                                                                                            ILI9341: Initialization complete
    2. Вместо ожидаемых надписей вижу if(непонятные символы 4 шт)p'xps(непонятные символы 2 шт)    
    Поправь форматирование логов. 
    Мы можем изменить ориентацию экрана на горизонтальную? 
    Давай потестируем шрифты, будем выводить шрифтом 19 последовательно все буквы английского алфавита и цифры. Плюс спец символы. В лог будем дублировать выводимые строки с учетом форматирования. 

10. 1. Логи исправлены. 
    2. Строки на дисплее. 1 строка - непонятные символы
    2 строка - bcdefghikl(непонятный символ)nopqrstuv(непонятный символ)xyz{
    3 строка - цифры правильные. 
    4 строка "(непонятный символ)$(непонятный символ)(непонятный символ)(непонятный символ)_'(непонятный символ))*'>\^|}(непонятный символ)(непонятный символ)(непонятный символ)?(непонятный символ)
    5 строка if(непонятные символы 4 шт)p'xps(непонятные символы 2 шт)  

11. 1 строка - непонятные символы   
    2 строка - dcb(символы обрезаны, далее трудно читаемое, видимо не то смещение)
    3 строка - Цифры отзеркалены и обрезаны, начинаются с 2 (нехватает правого крайнего столбца в символе цифры) (в прошлый раз цифры были корректными)
    4 строка - что-то не так со спец символами

12. 1 строка - в ряду непонятных символов корректно читается F ... IJ ........P... S....[    (все остальные символы этой строки ниже читаемых символов на половину высоты символа)
    2 строка - bcdefghikl(непонятный символ)nopqrstuv(непонятный символ)xyz{   (Нет буквы а)
    3 строка - цифры правильные. 

13. 1 Строка - ABCDEFGHI   идеально.
    2 Строка - начинается с буквы b и заканчивается k   bcdefghijk  
    3 Строка - цифры - идеально. 
    4 Строка - цифры большие - идеально. 
    5 Строка - IJ"

14. 1 Строка - ABCDEFGHI   идеально.
    2 Строка - начинается с буквы b и заканчивается k   bcdefghijk    
    3 Строка - цифры - идеально. 
    4 Строка - цифры большие - идеально. 
    5 Строка - HI!  - идеально.     
    Давай найдем маленькую букву 'a' для второй строки

15. 1 Строка - @ABCDEFGH  - нужно исправить. 
    2 Строка - abcdefghij  - идеально    
    3 Строка - /0123456789  цифры - первый символ не тот. 
    4 Строка - цифры большие - идеально. 
    5 Строка - HI!  - идеально.     
 
16. 1 Строка - ABCDEFGHI   идеально.
    2 Строка - начинается с буквы b и заканчивается k   bcdefghijk    
    3 Строка - цифры - идеально. 
    4 Строка - цифры большие - идеально. 
    5 Строка - HI!  - идеально.     
    Снова нет строчной буквы 'a' для второй строки, остальное всё идеально 

17  Добавил 1 символ перед прописной буквой 'a' 

18. 1 Строка - Font1 Uppercase: ABCDEFGHIJKLMNOPQRSTUVWXYZ  - идеально.                                           
    2 Строка - Font1 Lowercase: abcdefghijklmnopqrstuvwxyz  - идеально.
    3 Строка - в ряду непонятных символов корректно читается F ... IJ ........P... S....[    (все остальные символы этой строки ниже читаемых символов на половину высоты символа) 
    4 Строка - abcdefghijklmnopqrstuvwxyz   (проблема с буквой m и проблема с буквой w)
 
19 На базе шрифта Font1 сделай шрифт покрупнее 

20 сделай файл с конфигурационными дефайнами. Сделай дефайн для текущего таска - вывод алфафита двумя шрифтами. 
    Сделай еще один дефайн, и давай под него сделаем таск - попробуем реализовать надпись Hello World! Как циклически бегущую строку Крупным шрифтом. 

21  Реализация двойной буферизации для бегущей строки. 

22  Заведи в конфиг файле еще один макрос для следующего таска.
    Нарисуй qwerty клавиатуру, каждая кнопка с названием символа должна быть отделена рамкой, для последующей реализации тачскрина.

23  Сдвинь клавиатуру ниже на высоту кнопок. 
    Сделай в конфиг файле 3 варианта цветовой палитры клавиатуры. 

24  Сделай в конфиге выбор между строчными буквами и заглавными.     

25  давай подвинем клавиатуру и кнопки ниже, на две высоты кнопок и нарисуем в верхней части экрана поле в рамке для ввода текста, заведем макрос в конфиг файле, будем туда писать текст, который нужно вывести в этом поле. 
    
26  Давай увеличим текстовое поле по высоте, уменьшим расстояние от текстового поля до клавиатуры, Сделаем возможность отображения двух строк на тектсовом поле. Для текста каждой строки свой макрос в конфиге.    

27 Клавиатуру  нужно опустить ниже, она наехала поверх текстового поля. 

28 Вынеси в отдельный файл формирование фреймбуфера, напиши в нем подробные комментарии с настройками позиций элементов размеров кнопок и отступами. 

29 Добавь кнопки '.' за буквой m, и  ','

30 Добавь в ниженем ряду кнопки 
    1. Переключения регистра, 
    2. пробел, 
    3. Язык, 
    4. Отмена, 
    5 Ввод, 
    6 Меню. 
    Можем задать для этих кнопок отдельный размер, чтобы умещались в нижий ряд по ширине. 

31 Добавь макрос в конфиг файл по которому будем выводить все координаты и размеры каждого элемента фреймбуфера в отладочный лог максимально подробно. 
можно со схематичным выводом     

32 
    Пробуем добавить тачскрин. 
    14.  T_IRQ TOUCH_IRQ PB9
    13.  T_DO  SPI2_MISO PB14
    12.  T_DIN SPI2_MOSI PB15
    11.  T_CS  SPI2_CS   PB13      
    10.  T_CLK SPI2_SCK  PB10    
    Давай заведем обработку тач-скрина в отдельном таске, в отдельном файле. Заведем макрос в конфиг файле, по которому будем разрешать работу тачскрина. 
    Заведем макрос для отладки тач скрина, и  будем выводить в лог координаты нажатий при наступлении событий. 

33    изменил предделитель частоты. Тактовая частота появилась, вижу chip селект и 1 зуб сигнала mosi. 
      пробую подключить тач скрин

34    Не поднимается cdc нет изображения на экране, нет сигналов на лог анализаторе. Где-то зависли. Проверь, у нас хватает ли стека и кучи

35   
    Minimum Heap Size 0x400
    Minimum Stack Size 0x800

36  Была проблема c Hard_Fault. Была проблема с запуском отладчика, была проблема с Hal_Delay() внутри тастов, 
    Было выделено не достаточно памяти для тасков, (используются большие массивы статических переменных для экранного буфера)    
    Сейчас видна инициализация тачскрина, видны прерывания от него, при нажатии на экран. 
    Работают Live Packet. Алфовит, и отрисовывается клавиатура. 

37  Задача. При получении прерывания от тачскрина - выводим в консольный лог сообщение, если  в конфиг файле установлен ENABLE_TOUCH_DEBUG = 1
    Сделанные доработки записываем в файл status.md списком, по мере выполнения. 

38  Давай Создадим файл 24..md и напишем туда план по реализации калибровки тачскрина. 
    Например, реализуем параметр активации функции калиборвки в конфиг файле, и привяжем к нему реализацию функции калибровки тачскрина. 
    Сделаем последовательный вывод нескольких точек на фреймбуфере с известными кооринатами, при получении прерывания от тачскрина, 
    будем вычислять калибровочные коэффициенты и выводить их в консольный лог, для последующего сохранения в конфиг файле как константные значения 
    калибровки. 

39   TOUCHSCREEN_CALIBRATION_ENABLED 1  
     1. Давай на экране напишем, что это режим калибровки. 
     Для всех надписей будем использовать Font1_2x 
     2. После вывода надписи можно сразу рисовать первую точку. 
     В логах пишем её координаты. 
     При получении прерывания от тачскрина пишем текущие полученные кооринаты, 
     и пишем разницу координат. И рисуем точку, на экране, отмеченную стиллусом, в которую мы попали. 
     Далее переходим к другим точкам. 
     После калибровки На экране выводим надпись - калибровка завершена. 
     И давай придумаем вариант, с возможностью выбора повторной калибровки, 
     с примененными коэффициентами. 
     Может нам сделать меню, типа сохранить результаты, сбросить результаты, повторить калибровку. 

40   1. Нет надписи, что это режим калибровки. Нет первой точки на экране. 
     Реши эти проблемы          

41   1. Нет надписи что включен режим калибровки после инициализации дисплея.      
     Клавиатуры мы не рисуем, если не выбран режим (TASK_QWERTY_KEYBOARD = 1)
     Таск калибровки должен запускаться, если выбран TOUCHSCREEN_CALIBRATION_ENABLED = 1
     перенеси таск калибровки и все функции калибровки в отдельный файл.  
     Сделай дефайн с временем задержки запуска таска калибровки после ресета. 
     Заведи хедер файл с файлу калибровки, где будут задаваться параметры 
     фреймбуфера - страницы калибровки. 
     Посмотри, сколько памяти нужно выделить под этот таск, учитывая объем статических переменных                                           


     Setting display to landscape mode                                    
FREERTOS: TouchTask was created                                      
MAIN: Starting touchscreen calibration                               
TOUCH: Starting touchscreen calibration                              
TOUCH: After delay, testing display                                  
TOUCH: Test rectangle drawn                                          
TOUCH: Screen cleared                                                
TOUCH: Title drawn                                                   
TOUCH: Instructions drawn                                            
TOUCH: First point drawn                                             
TOUCH: Calibration point 1 expected at: X=10, Y=10                   
                                                                     
TOUCH: Touch the displayed point to begin calibration                
Config check active                                                  
TOUCH: Interrupt received from touchscreen                           
TOUCH: Interrupt received from touchscreen                           
TOUCH: Event=1, X=208, Y=79, Pressure=680                            
                                                                     
TOUCH: Interrupt received from touchscreen                           
TOUCH: Event=1, X=206, Y=78, Pressure=685                            
                                                                     
TOUCH: Interrupt received from touchscreen                           
TOUCH: Interrupt received from touchscreen                           
TOUCH: Ready for point 3 at X=310, Y=230                             
                                            

42 
 1. void MX_FREERTOS_Init(void) {
  тут мы не делаем никаких консольных логов, это приводит к зависанию на Get_Tick() при старте, 
  т.к. Hal_Delay() не работает в тасках фриротос. 

  CalibrationTask
  TOUCH_CALIBRATION_Init();


  Первую точку вижу  X=10, Y=10, но когда мы её нажимаем, получаем 
  координаты  X=289, Y=225 
  противоположного угла экрана, (320x240)

  Setting display to landscape mode                                    
FREERTOS: TouchTask was created                                      
MAIN: Starting touchscreen calibration                               
TOUCH_CAL: Starting touchscreen calibration                          
TOUCH_CAL: After delay, testing display                              
TOUCH_CAL: After delay, testing display                              
TOUCH_CAL: Screen cleared                                            
TOUCH_CAL: First point drawn                                         
TOUCH_CAL: Calibration point 1 expected at: X=10, Y=10               
                                                                     
TOUCH_CAL: Touch the displayed point to begin calibration            
CALIBRATION: Task completed                                          
TOUCH_CAL: Screen cleared                                            
TOUCH_CAL: First point drawn                                         
TOUCH_CAL: Calibration point 1 expected at: X=10, Y=10               
                                                                     
TOUCH_CAL: Touch the displayed point to begin calibration            
Config check active                                                  
TOUCH: Interrupt received from touchscreen                           
TOUCH: Interrupt received from touchscreen                           
TOUCH: Event=1, X=289, Y=225, Pressure=1299    

Этот код перенеси в файл с калибровкой 

    // Handle calibration UI updates in main task (not in interrupt!)
    if (calibration_active == 1) {  // Calibration mode
        // Check if we need to update the UI after a touch
        if (calibration_step != last_calibration_step) {
            // Clear screen and show touch feedback
            ILI9341_FillScreen(ILI9341_BLACK);

            // Show blue touch point briefly
            if (!touch_feedback_shown && calibration_step > 0) {
                calibration_point_t *last_point = &calibration_points[calibration_step - 1];
                ILI9341_FillRectangle(last_point->raw_x - 2, last_point->raw_y - 2, 5, 5, ILI9341_BLUE);
                touch_feedback_shown = 1;
                osDelay(300);  // Show touch point for 300ms
            }

            // Clear screen again and redraw
            ILI9341_FillScreen(ILI9341_BLACK);

            if (calibration_step < 5) {
                // Redisplay title and instructions
                ILI9341_DrawStringLarge(10, 10, "Calibration Mode", ILI9341_WHITE, ILI9341_BLACK);
                ILI9341_DrawStringLarge(10, 35, "Touch the points", ILI9341_YELLOW, ILI9341_BLACK);

                // Draw next point (inline since function is static)
                if (calibration_step < 5) {
                    calibration_point_t *point = &calibration_points[calibration_step];
                    uint16_t color = point->collected ? ILI9341_GREEN : ILI9341_RED;
                    ILI9341_FillRectangle(point->display_x - 10, point->display_y - 1, 20, 3, color);
                    ILI9341_FillRectangle(point->display_x - 1, point->display_y - 10, 3, 20, color);
                    char num_str[2] = {'1' + calibration_step, '\0'};
                    ILI9341_DrawString(point->display_x + 15, point->display_y - 10, num_str, ILI9341_WHITE, ILI9341_BLACK, 2, 0);
                }

                LOG_Printf("TOUCH: Ready for point %d at X=%d, Y=%d\r\n",
                           calibration_step + 1,
                           calibration_points[calibration_step].display_x,
                           calibration_points[calibration_step].display_y);
            } else {
                // All points collected, show completion menu
                TOUCH_ShowCalibrationMenu();
            }

            last_calibration_step = calibration_step;
            touch_feedback_shown = 0;
        }


  не работает:
  ILI9341_FillRectangle(0, 0, 50, 50, ILI9341_RED);

  работает:
  ILI9341_FillRectangle(100, 10, 20, 20, ILI9341_RED);  
  не понятно почему, потом разберемся. 
