# Оптимизация перерисовки дисплея ILI9341

## Проблема мерцания (flickering)

Текущая реализация бегущей строки вызывает мерцание из-за полного стирания области перед каждой отрисовкой текста. Это происходит потому, что:

1. **ILI9341_FillRectangle()** стирает область черным цветом
2. **ILI9341_DrawStringLarge()** рисует новый текст
3. Процесс повторяется каждые 50ms

## Варианты оптимизации

### 1. **Частичное обновление (Partial Update)**

Вместо полного стирания области, стирать только ту часть, которая изменилась:

```c
// Вместо полного стирания области
ILI9341_FillRectangle(0, 100, 320, 40, ILI9341_BLACK);

// Стирать только старую позицию текста
int old_text_end = scroll_pos + text_width;
if (old_text_end > 0 && old_text_end < 320) {
    ILI9341_FillRectangle(old_text_end, 100, 320 - old_text_end, 40, ILI9341_BLACK);
}
```

### 2. **Двойная буферизация (Double Buffering)**

Создать виртуальный framebuffer в RAM и обновлять только изменившиеся пиксели:

```c
#define FRAMEBUFFER_SIZE (320 * 240 * 2) // 320x240 RGB565 = 153600 bytes
static uint16_t framebuffer[FRAMEBUFFER_SIZE];

// Функция обновления только изменившихся областей
void ILI9341_UpdateChangedAreas(uint16_t *new_framebuffer) {
    // Сравнить с текущим framebuffer и обновить только различия
    // Отправить только изменившиеся прямоугольники
}
```

### 3. **DMA для SPI передачи**

Использовать DMA для асинхронной передачи данных на дисплей:

```c
// Включить DMA для SPI
void ILI9341_InitDMA(void) {
    // Настройка DMA канала для SPI1_TX
    // Передача данных в фоне
}

// Асинхронная передача
void ILI9341_WriteDataDMA(uint16_t *data, uint32_t size) {
    HAL_SPI_Transmit_DMA(&hspi1, (uint8_t*)data, size * 2);
}
```

### 4. **Оптимизация протокола дисплея**

Использовать команды ILI9341 для более эффективного обновления:

```c
// Memory Write Continue - продолжение записи в память
ILI9341_WriteCommand(ILI9341_GRAM);
ILI9341_WriteData16(color); // Первый пиксель
// Продолжить запись без повторных команд

// Vertical Scrolling - аппаратная прокрутка
ILI9341_WriteCommand(0x37); // Vertical Scrolling Start Address
ILI9341_WriteData16(scroll_line);
```

### 5. **Умная перерисовка текста**

Перерисовывать только изменившиеся символы:

```c
// Вместо полного перерисовки текста, обновлять только движущиеся символы
void SmartTextUpdate(int old_pos, int new_pos, const char *text) {
    // Найти разницу между старой и новой позицией
    // Обновить только новые видимые символы
    // Стереть символы, которые ушли за край
}
```

### 6. **Буфер команд дисплея**

Накапливать команды и отправлять пакетами:

```c
#define CMD_BUFFER_SIZE 1024
static uint8_t cmd_buffer[CMD_BUFFER_SIZE];
static int cmd_index = 0;

void ILI9341_BufferCommand(uint8_t cmd) {
    if (cmd_index < CMD_BUFFER_SIZE) {
        cmd_buffer[cmd_index++] = cmd;
    }
}

void ILI9341_FlushBuffer(void) {
    // Отправить все команды одним пакетом
    HAL_SPI_Transmit(&hspi1, cmd_buffer, cmd_index, HAL_MAX_DELAY);
    cmd_index = 0;
}
```

### 7. **Использование DMA2D (STM32F4/F7)**

На STM32 с DMA2D можно ускорить копирование областей:

```c
void DMA2D_CopyRegion(uint16_t *src, uint16_t *dst, int width, int height) {
    // Настройка DMA2D для быстрого копирования прямоугольников
    DMA2D->CR = 0;
    DMA2D->FGMAR = (uint32_t)src;
    DMA2D->OMAR = (uint32_t)dst;
    DMA2D->FGOR = 0;
    DMA2D->OOR = 0;
    DMA2D->NLR = (width << 16) | height;
    DMA2D->CR = DMA2D_M2M;
}
```

### 8. **Асинхронные обновления**

Обновлять дисплей в фоне, не блокируя основной поток:

```c
// FreeRTOS задача для обновления дисплея
void DisplayUpdateTask(void *argument) {
    while (1) {
        // Ожидать события обновления
        xSemaphoreTake(display_semaphore, portMAX_DELAY);

        // Выполнить обновление дисплея
        ILI9341_FlushBuffer();

        // Небольшая задержка
        vTaskDelay(16); // ~60 FPS
    }
}
```

### 9. **Оптимизация SPI**

Увеличить скорость SPI и использовать 16-битный режим:

```c
// Настройка SPI на максимальную скорость
SPI_InitStruct.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2; // 36MHz
SPI_InitStruct.DataSize = SPI_DATASIZE_16BIT; // 16-bit mode
```

### 10. **Тройная буферизация**

Использовать три буфера для максимальной плавности:

```c
uint16_t buffer1[FRAMEBUFFER_SIZE]; // Текущий кадр
uint16_t buffer2[FRAMEBUFFER_SIZE]; // Следующий кадр
uint16_t buffer3[FRAMEBUFFER_SIZE]; // Рабочий буфер

// Постоянно рендерить в buffer3, копировать в buffer2, отображать buffer1
```

## Рекомендации по реализации

### Для бегущей строки:
1. **Частичное обновление** - стирать только уходящие символы
2. **DMA SPI** - асинхронная передача
3. **Оптимизация задержки** - увеличить до 30-50ms

### Для статичного текста:
1. **Однократная отрисовка** - не перерисовывать постоянно
2. **Буфер команд** - накопление и пакетная отправка

### Для анимации:
1. **Двойная буферизация** - рисовать в фоне, показывать готовый кадр
2. **DMA2D** - аппаратное копирование областей
3. **Асинхронные обновления** - отдельная задача

## Производительность

- **Текущая скорость**: ~10-20 FPS для бегущей строки
- **С DMA**: ~30-60 FPS
- **С двойной буферизацией**: ~60 FPS и выше
- **Цель**: Плавная анимация без мерцания

## Заключение

Основные причины мерцания:
- Полное стирание области перед отрисовкой
- Синхронная передача по SPI
- Отсутствие буферизации

Лучшие решения для бегущей строки:
1. **Частичное стирание** старых символов
2. **DMA для SPI** передачи
3. **Увеличение периода обновления** до 30ms
